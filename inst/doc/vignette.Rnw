
% NOTE -- ONLY EDIT ScISI.Rnw!!!
%
%\VignetteIndexEntry{ScISI Vignette}
%\VignetteDepends{}
%\VignetteKeywords{Interactome}
%\VignettePackage{ScISI}
\documentclass{article}

\usepackage{hyperref}

\textwidth=6.2in
\textheight=8.5in
%\parskip=.3cm
\oddsidemargin=.1in
\evensidemargin=.1in
\headheight=-.3in

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textsf{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rfunarg}[1]{{\texttt{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}



\newcommand{\classdef}[1]{%
  {\em #1}
}

\begin{document}
\title{Creating In Silico Interactomes}
\author{Tony Chiang}
\maketitle

\section{Introduction}
With the advent of bait to prey technologies such as co-immunoprecipitation
(CO-IP), affinity purification - mass spectroscopy (AP-MS), and tandem 
affinity purification (TAP), high through-put data sets have become available
in the determination of protein complex co-membership. We remark that such 
technologies cannot assay an interactome 
(the set of protein complexes in a particular cell or
tissue under some conditions) without the addition of error (cite Chiang, et al). 
These errors come 
in two different ways: either a protein $p$ is pulled down with a protein 
complex in which $p$ does not belong and a false positve (FP) observation has 
been recorded or a protein $q$ is absent from the pull down of a protein 
complex to which $q$ truly belongs and a false negative (FN) observation has 
been recorded. 

The need to decipher these errors, either FP or FN, from true protein complexes
has lead many to develop protein complex co-membership algorithms. These 
algorithms use different statistical and mathematical models to extrapolate the
underlying interactomes - which protein complexes are present in the cell or 
tissue and each protein complex's composition.

Many of these algorithms estimate the underlying interactomes as certain networks.
Two entirely different networks become useful in the description of these 
interactomes. The first is a direct binary interaction graph where expressed 
protein constitute the vertex set of the graph, and two vertices are adjacent if
and only if their corresponding proteins directly interact with each other. 
While this protein-protein interaction (PPI) network is of fundamental 
importance to the understanding of biological processes, these protein 
associations cannot be inferred from bait to prey technologies such as TAP
or CO-IP. The second network is recognized as a protein complex membership structure 
encapsulated in the form of a hyper-graph. Again, expressed proteins represent 
the vertex set of the hyper-graph. The hyper-edges, which  can be any subset
of the vertex set, is comprised of the clusters of proteins which determine the 
protein complexes. It is important to note that a hyper-graph is a generalization
of an ordinary graph with the restriction that all hyper-edges have cardinality
at most two. By providing an estimate of these hyper-graphs, these algorithms 
provide a necessary computational tool in the study of bio-physical and cellular
processes.

A natural question arises concerning the statistical significance of these 
estimation algorithms. Because scientists do not have the actual blueprint 
of the interactome(s) for which they are testing (otherwise, the experiments 
would be irrelevant), there is no clear methodology in discerning the accuracy of 
any protein estimation algorithm. Most tests for significance (of such algorithms)
compare the estimates with protein complexes found in databases such as the 
Saccharomyces Genome Database, the Stanford Genomic Resources, or Gene Ontology. 
Such tangential tests for significance underscore the need for additional computational 
resources so more direct methodologies can be used to ascertain statistical 
significance.

To this end, we have developed the R-package \Rpackage{ScISI}. \Rpackage{ScISI} 
builds an \textit{in silico} interactome within some set of parameters defined
by the user for Saccharomyces cerevisiae. Presently, \Rpackage{ScISI} parses through three 
different data sets and culls those elements that best represents the protein 
complexes of interest. Two data sets are online yeast genome databases, Gene 
Ontology and the Munich Information Center for Protein Sequences. The last data
set is a collection of estimates from three different wet-lab experiments 
(cite Gavin, Ho, Krogan) derived from the \Rpackage{apComplex} package. Once 
an \textit{in silico} interactome is built, the R package \Rpackage{simulatorAPMS} 
can simulate AP-MS experiments rendering data sets very similar to those of actual wet-
lab experiments. Estimates for the \textit{in silico} interactome can be generated
by applying the algorithms on the simulations, and, thus, a canonical methodology
is available to test the statistical significance of the different estimation
algorithms.

This document will detail the various functions of \Rpackage{ScISI} by creating a
running example for an \textit{in silico} interactome. It is recommended that the reader
has a working session of $R$ and investigates the examples as they arise. 



<<loadlibs>>=

library(ScISI)

@

\section{Obtaining Information}

Before an \textit{in silico} interactome can be assembled, we must obtain the necessary
information. As remarked earlier, two sources are online databases, Gene Ontology (GO) 
and the Munich Information Center for Protein Sequences (MIPS), and the third is a 
catalogue of \Rpackage{apComplex} estimates from three wet-lab experiments. We start by 
discussing how information is parsed from the GO and MIPS databases.

Parsing through the GO database to collect the required information is done by calling the
\Rfunction{getGOInfo} function:

<<getGOInfo, eval=TRUE>>=
go = getGOInfo(wantDefault = TRUE, toGrep = NULL, parseType=NULL, 
               eCode = NULL, wantAllComplexes = FALSE)
@

All the information that is obtained from the \Rfunction{getGOInfo} function comes from the $R$
packages \Rpackage{GO} and \Rpackage{GOstats}. \Rfunction{getGOInfo} essentially parses 
through the Cellular Component (CC) of GO and (a)greps for specified key terms within certain 
boundary conditions. The parsing is carried out on terms (i.e. character vectors) together with 
perl regular expressions (this accounts for a boundary condition on protein complexes). 
The parameters of \Rfunction{getGOInfo} have the following characteristics:

\begin{itemize}
\item[1] \Rfunarg{wantDefault}: This is a logical. If passed into the function as TRUE, 
three default terms will be parsed: complex by agrep, ase by grep, and 
some by grep.

\item[2] \Rfunarg{toGrep}: A named list with only one entry named ``pattern'' supplied. 
The pattern entry holds a character vector of terms, with perl regular expressions,
supplied by the users. \Rfunction{getGOInfo} will parse for these terms within the CC 
ontology. If toGrep is not NULL, parseType must not be NULL neither.

\item[3] \Rfunarg{parseType}: A character vector of parse terms, e.g. ``grep'' or ``agrep''. 
This vector must either be of length one or of the same length as the vector toGrep. If 
parseType is of length one, all entries of toGrep will be parsed uniformly. Otherwise, the 
$i^{th}$ entry from parseType defines the command for the $i^{th}$ entry from toGrep.

<<getGOInfoToGrep, eval=TRUE>>=
toBeParsed = list()
toBeParsed$pattern = "\\Bsomal\\b"
goGrep = getGOInfo(wantDefault = TRUE, toGrep = toBeParsed, parseType = "grep",
                   eCode = NULL, wantAllComplexes = FALSE)
length(go)
length(goGrep)
setdiff(names(goGrep), names(go))

@ 

\item[4] \Rfunarg{eCode}: A character vector of evidence code terms (cite here). The is 
another boundary condition; whereas perl regular expression operated on protein complexes, 
the evidence codes operate on the proteins themselves. If a protein is only referenced by 
evidence codes found within the eCode vector, it is dis-allowed and removed from the protein 
complex. 

<<getGOInfoCoded, eval = TRUE>>=
  goCoded = getGOInfo(wantDefault = TRUE, toGrep = NULL, parseType = NULL,
                      eCode = "IEA", wantAllComplexes = FALSE)
@ 

\item[5] \Rfunarg{wantAllComplexes}: A logical. If TRUE, the children of parsed nodes will 
also be returned (accounting for sub-complexes). In addition, nodes that are children of 
the node ``GO:0043234'' (the protein complex node) are returned as well. 
\end{itemize}

<<getGOInfoOut, eval=TRUE>>=
class(go)
names(go)[1:10]
go$"GO:0005830"

@ 

The return value of \Rfunction{getGOInfo} is a named list. The names corresond to nodal GO id's,
and the entries of the list correspond to the composition of that GO id. The list is one way to
represent the hyper-graph. Each entry of the return value $go$ represents a particular hyper-
edge, and the union over all the entries of the list (i.e. over all the hyper-edges) yields the
vertex set.

Parsing for information from the MIPS database (completely analogous to parsing the GO database) 
is done by calling the \Rfunction{getMipsInfo} function:

<<getMipsInfo, eval=TRUE>>=
mips = getMipsInfo(wantDefault = TRUE, toGrep = NULL, parseType = NULL, 
                   wantAllComplexes = FALSE)


@

Unlike the \Rfunction{getGOInfo} function, \Rfunction{getMipsInfo} parse through two files 
downloaded from the complex catalogue of the MIPS database. One file contains a hierarchical 
clustering methodolgy for protein complexes while the second file contains the protein 
composition of each of the levels of the hierarchical clustering from the first. Thes files 
are updated bi-annually, so it is important to note that \Rfunction{getMipsInfo} should be 
updated periodically to correspond with the newer data files. With the exception of evidence 
codes and \Rfunarg{wantAllComplexes}, the functionality of \Rfunction{getMipsInfo} is identical 
to that of \Rfunction{getGOInfo}. MIPS does not use evidence codes to reference the proteins 
nor the protein complexes. Thus, the parameters of \Rfunction{getMipsInfo} have the following 
characteristics:

\begin{itemize}
\item[1] \Rfunarg{wantDefault}: This is a logical. If passed into the function as TRUE, 
three default terms will be parsed: complex by grep,  ase by grep, and 
some by grep.

\item[2] \Rfunarg{toGrep}: A named list with only one entry named ``pattern''.
The entry is a character vector containing terms, with perl regular expressions,
supplied by the users. \Rfunction{getMipsInfo} will parse for these terms within the 
hierarchical clusterings. If toGrep is not NULL, parseType must not be NULL neither.

\item[3] \Rfunarg{parseType}: A character vector of parse terms, e.g. ``grep'' or ``agrep''. 
This vector must either be of length one or of the same length as the vector toGrep. If 
parseType is of length one, all entries of toGrep will be parsed uniformly. Otherwise, the 
$i^{th}$ entry from parseType defines the command for the $i^{th}$ entry from toGrep.

<<getMipsInfoToGrep, eval=TRUE>>=
toBeParsed = list()
toBeParsed$pattern = "\\Bsomal\\b"
mipsGrep = getMipsInfo(wantDefault = TRUE, toGrep = toBeParsed, parseType = "grep",
                       wantAllComplexes = FALSE)
length(mips$Mips)
length(mipsGrep$Mips)
setdiff(names(mipsGrep$Mips), names(mips$Mips))

@ 

\item[4] \Rfunarg{wantAllComplexes}: A logical. If FALSE, only the top levels of the 
hierarchical clustering will be returned (the aggregate protein complex); if TRUE, 
all the intermediates of the hierarchical clustering will also be returned (the sub-
complexes as well). 
\end{itemize}

<<getMipsInfoEntries, eval=TRUE>>=
class(mips)
names(mips)
class(mips$Mips)
class(mips$DESC)
@ 

Another difference between the \Rfunction{getGOInfo} and \Rfunction{getMipsInfo} functions is 
their respective outputs. We have seen that the output from the \Rfunction{getGOInfo} is a named
list that represents the hyper-graph, but, from looking at the output printed above,
 this is not the case for the output of \Rfunction{getMipsInfo}. 



The output of \Rfunction{getMipsInfo} is a list with two 
entries: the first, $Mips$ is a named list of character vectors where the names are the MIPS ids
and the vectors contain proteins corresponding to its particular protein complex (i.e. it is also
a hyper-graph representation exactly like the \Rfunction{getGOInfo} output):

<<getMipsInfoMips, eval=TRUE>>=
names(mips$Mips)[1:10]
mips$Mips$"MIPS-510.40"
@ 

And the second is a
named character vector where the names correspond to MIPS ID and the entries contain a description
of its respective protein complex: 

<<getMipsInfoDESC, eval=TRUE>>=
names(mips$DESC)[1:10]
mips$DESC["510.40"]
@ 

The packages \Rpackage{GO} and \Rpackage{GOstats} have 
methods of returning descriptions of any GO id, and, therefore, it is irrelevant to create such 
a character vector containing the descriptions. Since there is no such methods for the MIPS 
dataset, it is necessary to record this vector as we parse the MIPS files. 

The third set from which we can obtain protein complex co-membership data is from the R 
package \Rpackage{apComplex}. Having been designed as a complex co-membership estimation
algorithm, \Rpackage{apComplex} takes wet-lab AP-MS data and produces consistent and 
uniform high level approximations for protein complex composition. Presently, there are three
publicly available AP-MS raw data sets (cite here) which have been processed by \Rpackage{apComplex}
and stored in its database. It is important to remark that the MIPS database also has these
three data sets (processed with methods developed by respective experiments) stored in its 
database; we have chosen to use the \Rpackage{apComplex} estimates, however, since it gives a level of 
consistency and uniformity unavailable elsewhere. We defer to the next section in obtaining
these three data sets, since their method of storage is that of an incidence matrix of 
a bi-partite graph (the definition of which follows).

It is a natural place to remark on the equivalence of the categories of hyper-graphs to the 
categories of bi-partite graphs. First suppose we have a hyper-graph; then for the bi-partite
graph, one set of vertices is again the set of expressed proteins while the other set of 
nodes consists of the hyper-edges of the known hyper-graph. Edges within the bi-partite graph 
is given by membership, i.e. protien $p$ is incident to hyper-edge $h$ if and only if $p$ is 
a member of the protein complex represented by $h$. The other direction is trivial, for if we are
given a bipartite graph, we can reconstruct the hyper-edge $h$ by taking the collection of 
proteins $p$ which are incident to a node $h$. Thus we can construct all hyper-edges and thus
the hyper-graph. The bi-partite graph representation will be used more frequently though we
will use both representations inter-changeably.

\section{Incidence Matrix Representation of Bi-Paritite Graphs}

Now that we have derived two parts of our \textit{in silico} interactome from the GO and MIPS 
databases, we need to modify the data structure to one that more flexible and resiliant for
computational methodologies. Most computational tools will rarely take the hyper-graph 
structure in its list representation; rather, computational tools generally use the matrix 
representation of the bi-partite graphs.

The incidence matrix, $M$, of bi-partite graphs has its rows indexed by proteins and has its columns
indexed by the protein complexes. $M_{i,j} = 1$ if and only if protein $i$ is a member of complex $j$,
and $M_{i,j} = 0$ otherwise. Therefore, $M$ is a $\{0,1\}$ matrix which is generally sparse.

The function \Rfunction{createGOMatrix} takes the output of \Rfunction{getGOInfo} and creates the 
bi-partite graph incidence matrix of this hyper-graph list. 

<<createGOMatrix, eval=TRUE>>=
goM = createGOMatrix(go)
@ 

We remark that we the proteins names used to index the rows of the incidence matrix are the 
standard gene names for yeast. To establish uniformity, we have used the standard gene names
across all data sets. The colunmes of the incidence matrix are indexed by the GO id's 
corresponding to certain protein complexes.

<<createGOMatrixOut, eval=TRUE>>=
goM[1:10, 1:6]
@ 

The MIPS bi-partite graph incidence matrix is created exactly as the GO bipartite graph incidence
matrix. The argument for \Rfunction{createMipsMatrix} is the output from \Rfunction{getMipsInfo}.

<<createMipsMatrix, eval=TRUE>>=
mipsM = createMipsMatrix(mips)
@ 

Again we see that the standard gene names for yeast index the rows of the MIPS incidence matrix
and the the MIPS id's corresponding to protein complexes index the columns. It is important to 
note that \Rfunction{createMipsMatrix} has prefixed each of the MIPS id's with the term ``MIPS-''.
This is useful when we merge difference incidence matrices, for it allows us to know where each
protein complex orginates.

<<createMipsMatrixOut, eval=TRUE>>=
mipsM[1:10, 1:6]
@ 

The last three bi-partite graph incidence matrices have already been created and stored as 
data files in the \Rpackage{apComplex} package. There are currently three data sets 
corresponding to the three available wet-lab experiments (cite 3 experiments). These three
incidence matrices can be obtained by calling the function \Rfunction{getAPMSData} with
one of the following arguments: ``Gavin'', ``Ho'', or ``Krogan''.

<<getAPMSData, eval=TRUE>>= 
gavin = getAPMSData("Gavin")
ho = getAPMSData("Ho")
krogan = getAPMSData("Krogan")
@ 

The complexes
that are reported from \Rpackage{apComplex} are high level estimates of direct wet-lab 
experimental data. One further step has been taken to produce higher quality complexes:
only those estimates which fall under the multi-bait (more than one protein in the complex 
was used as a bait protein in the AP-MS techonology) and multi-hit (multiple proteins within 
the reported complex were actually pulled down as prey) were taken to be high quality protein
complex estimates. 

<<getAPMSDataOut, eval=TRUE>>=
gavin[1:10, 1:6]
@ 

Again the bi-partite graph incidence matrix are indexed in the rows by the yeast standard 
gene names, but since there are no complex id's for the estimates reported by \Rpackage{apComplex},
the \Rfunction{getAPMSData} function denominates ad hoc id's for these complexes. The columns
are indexed by such ad hoc ids which reference the wet-lab experiments from where the were 
derived.


\section{Comparing Protein Complexes Across Databases}

Now that we have obtained the various bi-partite graph incidence matrices, we need to evaluate and 
cross reference the protein complexes across databases and eliminate redundancy. There are two items 
for which we must find when cross referencing protein complexes: equality or inclusion. To compare
two bi-partite graph incidence matrices, we use the \Rfunction{funCompareComplex} function:

<<runCompareComplex, eval=TRUE>>=
mips2go = runCompareComplex(mipsM, goM, byWhich="BOTH")
names(mips2go)
@ 

The \Rfunction{runCompareComplex} function takes two bipartite-graph incidence matrices as arguments,
and compares each complex from the first bipartite graph to the each complex from the second 
bi-partite graph. The argument $byWhich$ shall be elucidated in the following paragraphs.
 The output of this function is a named list whose entries carry various statistical
information. An explanation of each entry follows:

\subsection{Jaccard Coefficients}
The $JC$ entry of $mips2go$ contains a matrix of the Jaccard similarity coefficient between 
the complexes of mips and the complexes of go. The $(i,j)^{th}$ entry of this matrix corresponds to 
the Jaccard similarity between the $i^{th}$ complex of mips and the $j^{th}$ complex of go. The 
coefficient is calculated by taking the quotient of the cardinality of the intersection of these 
complexes $mips_i \cap go_j$ by the cardinality of the union of the same complexes 
$mips_i \cup go_j$:

\begin{equation}
JC_{i,j} = \frac{|mips_i \cap go_j|}{|mips_i \cup go_j|}.
\end{equation}

<<runCompareComplexJC, eval=TRUE>>=
  mips2go$JC[1:5,1:5]
@ 

Equality of complexes returns a Jaccard index of unity while disjoint complexes return zero. We 
remark that if one complex completely contains another, e.g. $go_j \subset mips_i$, the Jaccard 
index will be the cardinality of $go_j$ quotient the cardinality of $mips_i$: 

\begin{equation}
\frac{|go_j|}{|mips_i|};
\end{equation}

it is important 
to realize that containment is not easily ascertained without the orders of each complex at hand.

\subsection{Alignment of Protein Complexes}
The $maxIntersect$ entry of mips2go aligns either the complexes of $go$ to complexes
of $mips$ or complexes of $mips$ to complexes of $go$ or both. We define alignment in this 
context to mean for a given protein complex of one bipartite graph which complex(es) in the second
bipartite graph will return a maximal Jaccard coefficient. While not obvious, it is not hard to 
prove that this operation is not symmetric, and therefore the $byWhich$ argument in 
\Rfunction{runCompareComplex} instructs the function as to which alignment to produce: ``ROW'' 
compares all the complexes of the second bi-partite graph with each complex to the first; ``COL''
compares all the complexes of the first bi-partite graph with each complex of the second; and 
``BOTH'' will produce both the the outputs. It is clear then that this type of alignment is not
injective, surjective, nor even well defined, i.e. it is not a function but rather a set mapping. 

<<runCompareComplexMaxInterSect, eval=TRUE>>=
names(mips2go$maxIntersect)
@ 

The $maxIntersect$ entry is itself a named list with two entries: maximize and maxComp. The maximize 
entry records the maximum Jaccard coeffiencts for each of the complex aligned either by ``row'' or by
``column'' or both if they are both called. The maxComp entry contains
a named list also either by ``row'' or ``column''; the names of the list correspond to the complex 
aligned and the entries to the list are those indices for the complexes for which produce the highest 
Jaccard index (the indices references where the are located with respect to the named vector
colnames(bgMatrixN)).

<<runCompareComplexMImaxComp, eval = TRUE>>=

mips2go$maxIntersect$maximize$row[1:5]
mips2go$maxIntersect$maxComp$row[1:5]

@ 

\subsection{Equality of Protein Complexes}
The $equal$ entry records protein complexes of the first bi-partite graph matrix equal to those
in the second. To produce an \textit{in silico} interactome, we will eventually merge the different 
bi-partite graph matrices, and if two different bi-partite graphs have common protein complexes, we need
to determine those complexes and eliminate redundancy. 

<<runCompareComplexEqual, eval=TRUE>>=
length(mips2go$equal)
names(mips2go$equal[[1]])
mips2go$equal[[1]]
@ 

The $equal$ entry is a list of list which in turn has five entries: ``BG1Comp'' records the complex
of the first bi-partite graph; ``BG2Comp'' records the complex of the second bi-partite graph; 
``orderBG1Comp'' records the cardinality of ``BG1Comp''; analogously for ``orderBG2Comp''; and 
finally, ``intersect'' records the cardinality of $BG1Comp \cap BG2Comp$. Rather than just recording
the complex names, this data structure allows the user to inspect relative size of those common 
complexes. 

\subsection{Eliminating Redundancy}
The ``toBeRm'' entry takes only those protein complexes of the first bi-partite graph (in our
running example, this would be mips or equivalently mipsM) which are equal to some protein complexes 
of the second bi-partite graph. The result is a character vector of protein complexes that will need
to be deleted in order to avoid redundancy in the \textit{in silico} interactome. 

<<runCompareComplexRm, eval=TRUE>>=
length(mips2go$toBeRm)
for(i in 1:5){
print(mips2go$toBeRm[i] == mips2go$equal[[i]][1])
} 
mips2go$toBeRm[1:5]
@ 

\subsection{Protein Sub-Complexes}
The ``subcomplex'' looks for any complex from one bi-partite graph which is completely contained
in a complex from the other bi-partite graph. The outputs in this entry are identical to those of the 
$equal$ and defer the reader to the explanation written previously.

<<runCompareComplexSub, eval=TRUE>>=
mips2go$subcomplex[[1]]
@ 

While the storage of the data does not explicitly state which complex contains the other complex, it is 
pretty clear that the sub-complex must have the smaller cardinality. It is quite evident that if two 
complexes are equal, then one of the two complexes must be removed to eliminate redundancy; it is not 
clear, however, whether or not to remove sub-complexes. For the purpose of simulating AP-MS technology,
sub-complexes will be masked by the aggregate complex, and thus, removal is needed to avoid 
redundancy. There may be other computational tools that require the availability of the sub-complexes, 
so there is consistent framework calling for the removal of sub-complexes, and hence, we
leave that decision to the users.

\section{Combining Bi-Partite Graphs - Building In Silico Interactomes}

After we have called the \Rfunction{runCompareComplex} function on two different bi-partite graph 
matrices, we can merge these repsective graph matrices to form an aggregate
 incidence matrix and thus creating an aggregate bi-partite graph. The aggregate bi-partite 
graph, $A$, has certain important characteristics: the rows of $A$ are indexed by the union of 
the proteins of the two constituent bi-partite graphs and the columns are indexed by the union
of the protein complexes of the two constituent bi-partite graphs.

To merge two incidence matrices, we simply call the \Rfunction{mergeBGMat} function:
<<mergeBGMat, eval=TRUE>>=
  dim(mipsM)
  dim(goM)
  merged = mergeBGMat(mipsM, goM, toBeRm = mips2go$toBeRm)
  dim(merged)
  merged[1:10, c(1:2, 200:202)]
@ 

The first two arguments of the \Rfunction{mergeBGMat} function is two bi-partite graph incidence
matrices, and the last argument is a character vector of those protein complexes which should be 
deleted in order to avoid redundancy.

Once two bi-partite graphs are merged, we can now call the \Rfunction{runCompareComplex} on the $merged$
incidence matrix and a new bi-partite graph matrix (one which is not any of the constituent 
matrices of $merged$). In such a way, we can construct the \textit{in silico} interactome
iteratively by merging a new incidence matrix in each subsequent iterations. As examples, the user
is encouraged to merge the AP-MS data with the newly created $merged$ matrix.

\section{Customizing the Interactome}
We have successfully built an \textit{in silico} interactome, and for some computational methodologies,
this interactome is the best interactome to use. In this section, we present some other functions within
\Rpackage{ScISI} that allows the users to refine the interactome from the coarser one built. 

\subsection{Generating an Instance of Class yeastData}
One of the functionalities of the \Rpackage{ScISI} package is to create an instance of the class
\Rclass{yeastData}. Before we can instantiate this class, some preliminary functions need to be 
called. 

The class \Rclass{yeastData} will contain all the available information of some bi-partite graph, and
so we must collate these sets of information into one usable format. We can do this by calling either 
the \Rfunction{createGODataFrame} or \Rfunction{createMipsDataFrame} function. 

<<createDataFrame, eval=TRUE>>=
goDF = createGODataFrame(go, goM)
mipsDF = createMipsDataFrame(mips$DESC, mipsM)
@ 

The names of these two
functions describe the output quite explicitly, but the arguments need some clarification. The 
arguments for the both functions are essentially the same. The arguments for \Rfunction{createGODataFrame}
are:

\begin{itemize}
 \item[1] \Rfunarg{go} - A named list whose entries are character vectors. This is essentially the 
hyper-graph of the GO protein complexes. The GO id's are obtained by calling the \Rfunction{names} 
function on the list, and the description for the protein complexes is obtained by calling the
\Rfunction{getGOTerm} function from \Rpackage{GO}.
\item[2] \Rfunarg{goM} - The incidence matrix representing the GO hyper-graph. The names of the 
GO protein complexes are obtained by calling the \Rfunction{colnames} on this matrix.
\end{itemize}

The arguments for the function \Rfunction{createMipsDataFrame} are:

\begin{itemize}
\item[1]{mips\$DESC} - A named character vector. The MIPS' id's are obtained by calling \Rfunction{names}
on the vector, and the description is obtained by accessing the vector values.
\item[2]{mipsM} - The incidence matrix representing the MIPS hyper-graph. The names of the MIPS' 
protein complexes are obtained by calling the \Rfunction{colnames} on this matrix.
\end{itemize}

The generated database holds three distinct pieces of 
information for each protein complex: its name relative to the incidence matrix; its id (GO or MIPS);
and its description.

<<dataFrameOut, eval=TRUE>>=
head(mipsDF)
@ 

Once we have created either the GO dataframe or the MIPS dataframe, we can proceed to call an 
instance of the \Rclass{yeastData} class. Instantiating an \Rclass{yeastData} object is done
by calling the \Rfunction{createYeastDataObj} function:

<<createYeastDataObj, eval=TRUE>>=
mipsOb = createYeastDataObj(mipsDF)
@ 

With the instance of the \Rclass{yeastData} class, we have access to three generic methods: 
\Rmethod{ID}, \Rmethod{Desc}, and \Rmethod{getURL}. 

<<yeastDataMethods, eval=TRUE>>=
ID(mipsOb, "MIPS-510.40")
Desc(mipsOb, "MIPS-510.40")
getURL(mipsOb, "MIPS-510.40")
@ 

The arguments for each of the methods are identical: the first argument (\Rfunarg{mipsOb} in 
our running example) is the instance of \Rclass{yeastData}; the second argument 
(``MIPS-510.40'' in the running example) is the name of the protein complex as 
defined in the incidence matrix \Robject{mipsM}, i.e. the column names. A good exercise is 
too create an instance of \Rclass{yeastData} with the GO dataframe and work with the 
generic methods.

The return values the \Rmethod{ID} and \Rmethod{Desc} are self-explanatory. The output for
\Rmethod{getURL} returns the url for the web-page containing a detailed description of the 
MIPS or GO protein complex. This allows the user to parse through the derived protein 
complexes manually and refine the \textit{in silico} interactome. Simply call the 
\Rfunction{browseURL} function with the output of \Rmethod{getURL} as the argument to open a 
browser with the specified web-page.


\subsection{Generating an Informational .html File}
Once we have created an instance of \Rclass{yeastData}, we can call the
\Rfunction{ScISI2html} function to generate a .html file in the user's home 
directory. 

<<ScISI2html, eval=TRUE, results = hide>>=
mipsNames = colnames(mipsM)
url = vector(length = length(mipsNames))
linkNames = vector(length = length(mipsNames))
for(i in 1:length(mipsNames)){
url[i] = getURL(mipsOb, mipsNames[i])
linkNames[i] = Desc(mipsOb, mipsNames[i])
}
ScISI2html(urlVect = url, linkName = linkNames, filename = "mips", title = "MIPS Protein Complex")
@ 

The arguments for the \Rfunction{ScISI2html} are somewhat self explanatory, but we will provide
a terse description of each argument:

\begin{itemize}

\item[1] \Rfunarg{urlVect} is a character vector consisting of url address for the protein complexes.

\item[2] \Rfunarg{linkName} is a character vector taht will be anchored by \Rfunarg{url}.

\item[3] \Rfunarg{filename} is a character that will name the file, e.g. in our running example, 
the output file will be named ``mips.html''.

\item[4] \Rfunarg{title} will be the title of the .html file.

\end{itemize}

The purpose for this .html file is a quick and efficient way for users to manually parse the 
protein complexes derived from \Rpackage{ScISi} either for quality control or for refinement.


\subsection{Cutting Interactomes with Gene Expression Time Series Data}

\section{Conclusion}

\section{References} 

\end{document}
