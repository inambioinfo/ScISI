%
% NOTE -- ONLY EDIT THE .Rnw FILE!!!  The .tex file is
% likely to be overwritten.
%
% \VignetteIndexEntry{Calculating Graph Stats}
%\VignetteDepends{}
%\VignettePackage{y2hStat}
\documentclass[11pt]{article}

\usepackage{times}
\usepackage{hyperref}

\usepackage[authoryear,round]{natbib}
\usepackage{times}
\usepackage{comment}

\textwidth=6.2in
\textheight=8.5in
%\parskip=.3cm
\oddsidemargin=.1in
\evensidemargin=.1in
\headheight=-.3in

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}

\bibliographystyle{plainnat}

\title{Calculating Summary Statistics on the Induced Y2H Graphs}
\author{T. Chiang}

\begin{document}

\maketitle

This document details how to obtain the Y2H graph summary statistics 
to validate the ScISI.

<<loadlibs>>=

library("ScISI")
library("y2hStat")

@

Presently, we are using Y2H experimental data in an attempt to validate
the protein complexes present in the in silico interactome. To this end, 
we simply need the \Robject{ScISI} which we have already built as well as
the various bait to prey experimental data which we have already parsed
from the Intact repository.

<<loadData>>=
data(ScISI)
data(y2hSysGW)
data(nucComp)
@ 

Currently, there are six summary statistics in which we are interested. 
The first two concern hyper-geometric sampling schemes to estimate 
edge proportions and the mean node degree of the induced Y2H graph under 
the assumptions that the Y2H experiments were perfectly sensative and 
specific (i.e. we did not record any FN nor any FP) and that the prey 
population is genome wide while the bait population is restricted to 
only those bait proteins which successfully found at least one prey.

 \begin{enumerate}
\item Edge Proportion\\
\begin{eqnarray*}
\frac{\hat{X}}{n(n-1)/2} & = & \frac{x}{[(n-1)+(n-2)+\ldots+(n-k)]} \\
\hat{X} & = & \frac{ x (n)(n-1)}{2 [(n-1)+(n-2)+\ldots+(n-k)]} \\
\end{eqnarray*}
\item Estimated Number of Edges based on Mean nodal degree\\
\[
\tilde{X} = \frac{ n \sum_{i=1}^k d_i}{2k}.
\]
\end{enumerate}



The latter four summary statistics is more robust with respect to 
experimental error. 

\begin{enumerate}
\item Sampled Baits\\
  For a given protein complex, $C_i$, find all complex members,
  $P_j$ that were used as a bait in some Y2H experiment. For these,
  compute the proportion that found at least one other member of the
  complex. If $P_j$ was used as a bait in more than one Y2H experiment
  do not double count, but take any positive result as positive.
\item Average Out-Degree \\
  For a given protein complex, $C_i$, find the average out-degree
  of all bait proteins, again avoid double counting, in this case by
  taking the maximum out-degree. Divide this by the complex size.
\item Un-isolated Proteins\\
  Given the number of proteins in a complex that are detected as
  either bait or prey, find the number that are connected to at least
  one other complex co-member. [Should this be the proportion of
  complex members that are connected to at least one other complex
  member?] 
\item Connected Components\\
  Compute the ratio of the number of edges needed to make the
  complex connected, by adding to the observed edges, divided by the
  minimum number of edges needed to create a connected graph from the
  complex. This is essentially a measure of incompleteness.
\end{enumerate}


We have generated a script to calculate each of these graph summary 
statistics:

<<graphStats>>=
#interestingComps <- colnames(ScISI) %in% nucComp

#ScISI2 <- ScISI[, interestingComps]

#graphStats <- graphSumStats(ScISI2, y2hSysGW)
#ncol(ScISI2)
#length(graphStats)
#names(graphStats[[1]])
@ 

We first mention why only a subset of the complexes of ScISI seem
to have been investigated with respect to the graph statistics. 
Only those complexes containing some bait protein with non-trivial
out degree can produce meaningful statistics (otherwise, we would 
have a quotient with 0 denominator). Thus we have chosen only to 
record meaningful complexes in our investigation.

The first two hyper-geometric sampling statistics are directly 
calculated by the \Robject{graphSumStats} script:

<<hyperGeo>>=
#graphStats[[2]]$edgeProp
#graphStats[[2]]$popMeanDeg
@ 

These two statistics give a reasonable estimate over each 
\Robject{ScISI} protein complex induced Y2H sub-graph. 

Each of the other four statistics needs a bit of simple manipulation 
to provide the final outcome.

We produce each in the order they are listed above:

<<sampledB>>=
#graphStats[[2]]$complexBait
#graphStats[[2]]$complex
#graphStats[[2]]$notBait
#sampledProp <- (length(graphStats[[1]]$b2CompP))/(length(graphStats[[1]]$complexBait))
#sampledProp
@ 

<<avgOut>>=
#graphStats[[2]]$avgOutDeg
@ 

<<notIsolated>>=
#graphStats[[2]]$notIsolated
@ 

<<connComp>>=

#cc <- connectedComp(graphStats[[2]]$y2hGraph)
#cc
#ratio <- (length(cc)-1)/(length(graphStats[[2]]$complex)-1)
#ratio
@ 

We use a contrived example to show that the calculations of hte
graph summary statistics is what we want it to be:





<<testEx>>=

exam <- matrix(0, nrow=10, ncol=4)
present <- c(1,3,4,7,10,12,15,16,19,21,26,29,34,35,36, 38)
exam[present] <- 1
#rnames <- c(letters[1:8],letters[17:18])
#cnames <- c("C1", "C2", "C3", "C4")
dimnames(exam) <- list(c(letters[1:10]), c("C1", "C2", "C3", "C4"))
y2h <- list()
y2h$exp1 <- list()
y2h$exp2 <- list()
y2h$exp3 <- list()
y2h$exp4 <- list()
y2h$exp1$a <- c("b","c","e","x","z","w")
y2h$exp1$d <- c("f","g","h","t","s")
y2h$exp1$g <- c("x","z")
y2h$exp2$a <- c("b","c","g","t")
y2h$exp2$e <- c("a","b","z")
y2h$exp2$z <- c("a","e")
y2h$exp3$h <- c("a","b","e")
y2h$exp4$z <- c("t","s","e","v")
y2h$exp4$w <- c("r","j")
y2h$exp4$c <- c("d","d")

t <- graphSumStats(exam, y2h)
#t

#cc <- connectedComp(t[["C4"]]$y2hGraph)

#ratio <- (length(cc)-1)/(length(t[["C4"]]$complex)-1)

#cc
#ratio
@

<<example2>>=
set.seed(235)
comp2 <- matrix(0, nrow = 10, ncol = 3)
ind <- sample(30, 12)
comp2[ind] = 1
dimnames(comp2) <- list(letters[11:20], c("Comp1","Comp2", "Comp3"))
comp2

baits <- sample(letters[11:20], 3)

interact <- list()
interact$exp1 <- list()
interact$exp1[[baits[1]]] <- letters[sample(1:26, 6)]
interact$exp1[[baits[2]]] <- letters[sample(1:26, 7)]
interact$exp2 <- list()
interact$exp2[[baits[3]]] <- letters[sample(1:26, 5)]
interact
t2 <- graphSumStats(comp2, interact)
t2

@ 

<<example3>>=
#comp = matrix(1, nrow = 10, ncol = 1)
#dimnames(comp) <- list(letters[1:10], "t")

#test <- list()
#test$exp1 <- list()
#test$exp1$a <- c("b", "d")
#test$exp1$c <- "e"
#test$exp2 <- list()
#test$exp2$a <- c("b", "e", "g")
#test$exp2$d <- "z"

#ex1 <- graphSumStats(comp, test)

@ 


\end{document}
